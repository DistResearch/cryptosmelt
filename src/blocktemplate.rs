use longkeccak::keccak;
use std::sync::atomic::*;
use std::sync::*;
use std::result::Result as StdResult;
use std::cmp::min;
use num_bigint::*;
use num_integer::*;
use uuid::*;
use jsonrpc_core::*;
use mithril::byte_string;
use mithril::cryptonight::*;
use cryptonightlite;
use concurrent_hashmap::*;
use reqwest;
use daemon_client::DaemonClient;
use app::App;

#[derive(Clone)]
pub enum HashType {
  Cryptonight,
  CryptonightLite,
}

fn cn_hash(input: &Vec<u8>, hash_type: &HashType) -> String {
  let aes = aes::new(aes::AESSupport::HW);
  match hash_type {
    &HashType::Cryptonight => hash::hash_alloc_scratchpad(input, &aes),
    // TODO there are a bunch of warnings generated by unused parts of cryptonightlite.rs
    &HashType::CryptonightLite => cryptonightlite::hash_alloc_scratchpad(input, &aes),
  }
}

#[test]
fn test_hash() {
  let input = byte_string::string_to_u8_array("");
  assert_eq!(cn_hash(&input, &HashType::Cryptonight), "eb14e8a833fac6fe9a43b57b336789c46ffe93f2868452240720607b14387e11");
  // Test case taken from https://github.com/ExcitableAardvark/node-cryptonight-lite
  assert_eq!(cn_hash(&input, &HashType::CryptonightLite), "4cec4a947f670ffdd591f89cdb56ba066c31cd093d1d4d7ce15d33704c090611");
  let input2 = byte_string::string_to_u8_array("5468697320697320612074657374");
  assert_eq!(cn_hash(&input2, &HashType::CryptonightLite), "88e5e684db178c825e4ce3809ccc1cda79cc2adb4406bff93debeaf20a8bebd9");
}

pub struct SuccessfulBlock {
  pub id: String,
  pub blob: String,
}

pub enum JobResult {
  BlockFound(SuccessfulBlock),
  SharesAccepted,
  SharesRejected,
}

pub struct Job {
  pub id: String,
  pub hash_type: HashType,
  pub height: u64,
  pub difficulty: u64,
  pub diff_hex: String,
  pub hashing_blob: String,
  // TODO consider just keeping an Arc to the original template, storing this stuff is redundant
  pub template_blob: String,
  pub extra_nonce: String,
  pub reserved_offset: u32,
  pub network_difficulty: u64,
  submissions: ConcHashMap<String, bool>,
}

impl Job {
  pub fn submit(&self, nonce: &String) -> JobResult {
    if nonce.len() != 8 {
      // We expect a hex representing a 32 bit integer.  We don't care so much about validating that
      // it is purely hexadecimal chaaracters, though, since string_to_u8_array will just zero out
      // anything non-hexadecimal.
      // TODO actually, probably check that it's hex to be safe
      return JobResult::SharesRejected;
    }
    let previous_submission = self.submissions.insert(nonce.to_owned(), true);
    if let Some(_) = previous_submission {
      // TODO we'll probably want some auto banning functionality in place here
      return JobResult::SharesRejected;
    }
    // TODO check if the block is expired, may want to do away with the template reference and just
    // check against the current template, since anything of a lower height will be expired as long
    // as we only keep one template per height
    let blob = &self.hashing_blob;
    let (a, _) = blob.split_at(78);
    let (_, b) = blob.split_at(86);
    let hash_input = byte_string::string_to_u8_array(&format!("{}{}{}", a, nonce, b));
    let hash = cn_hash(&hash_input, &self.hash_type);
    let hash_val = byte_string::hex2_u64_le(&hash[48..]);
    let achieved_difficulty = u64::max_value() / hash_val;
    if achieved_difficulty >= self.difficulty {
      if achieved_difficulty >= self.network_difficulty {
        // The construction of the block ID is similar to the proof-of-work hash, except that:
        // - The hash input is prefixed with a length value before hashing.  It's not obvious why
        //   this is necessary, but probably has something to do with the fact that keccak is the
        //   first step in cryptonight, and that it wouldn't seem right to have the eventual block
        //   ID be there at some point in the cryptonight state.
        // - The fast hashing function, keccak, is used instead of cryptonight.
        let mut input_with_length = to_varint(hash_input.len());
        input_with_length.extend(&hash_input);
        // TODO use a helper function for this map/collect/join byte formatting
        let block_id: Vec<String> = keccak(&input_with_length)[..32].to_vec().iter()
          .map(|b| format!("{:02x}", b))
          .collect();;
        info!("Valid block candidate {}", block_id.join(""));
        let start_blob = &self.template_blob[..78];
        // TODO is there a good reason for "- 2"?
        let middle_blob = &self.template_blob[86..(self.reserved_offset as usize * 2 - 2)];
        let end_blob = &self.template_blob[(self.reserved_offset as usize * 2 + 16)..];
        let block_candidate = format!(
          "{}{}{}{}{}",
          start_blob,
          nonce,
          middle_blob,
          self.extra_nonce,
          end_blob
        );
        return JobResult::BlockFound(SuccessfulBlock {
          id: block_id.join(""),
          blob: block_candidate,
        });
      }
      return JobResult::SharesAccepted;
    } else {
      warn!("Bad job submission");
    }
    JobResult::SharesRejected
  }
}

/// Returns a representation of the miner's current difficulty, in a hex format which is sort of
/// a quirk of the stratum protocol.
fn get_target_hex(difficulty: u64) -> String {
  let difficulty_big_endian = format!("{:08x}", 0xffffffff / difficulty);
  format!(
    "{}{}{}{}",
    // This isn't a particularly elegant way of converting, but miners expect exactly 4
    // little-endian bytes so it's safe.
    &difficulty_big_endian[6..],
    &difficulty_big_endian[4..6],
    &difficulty_big_endian[2..4],
    &difficulty_big_endian[..2],
  )
}

#[test]
fn target_hex_correct() {
  assert_eq!(get_target_hex(5000), "711b0d00");
  assert_eq!(get_target_hex(20000), "dc460300");
  assert_eq!(get_target_hex(1), "ffffffff");
}

pub struct JobProvider {
  // TODO eventually everything here should be private
  pub template: RwLock<BlockTemplate>,
  nonce: AtomicUsize,
  app: Arc<App>,
  hash_type: HashType,
}

impl JobProvider {
  pub fn new(app: Arc<App>) -> JobProvider {
    let hash_type = match app.config.hash_type.to_lowercase().as_ref() {
      "cryptonight" => HashType::Cryptonight,
      "cryptonightlite" => HashType::CryptonightLite,
      _ => panic!("Invalid hash type in config.toml"),
    };
    JobProvider {
      template: RwLock::new(Default::default()),
      nonce: AtomicUsize::new(0),
      app,
      hash_type,
    }
  }

  pub fn get_job(&self, difficulty: u64) -> Option<Job> {
    // The network difficulty typically only exceeds the network difficulty shortly after firing
    // up a testnet.  Aside from that, sending out jobs higher than the network difficulty would
    // be unlikely, but undesirable, since it would mean telling miners not to send in completed
    // blocks.
    let job_id = &Uuid::new_v4().to_string();
    let template_data = self.template.read().unwrap();
    let capped_difficulty = min(difficulty, template_data.difficulty);
    let target_hex = get_target_hex(capped_difficulty);
    let new_nonce = self.nonce.fetch_add(1, Ordering::SeqCst);
    // TODO maybe hashing_blob_with_nonce should take in a u64
    let extra_nonce = &format!("{:016x}", new_nonce);
    let new_blob = template_data.hashing_blob_with_nonce(extra_nonce);
    // TODO do this more idiomatically
    match new_blob {
      Some(new_blob) => Some(Job {
        id: job_id.to_owned(),
        hash_type: self.hash_type.clone(),
        height: template_data.height,
        difficulty: capped_difficulty,
        diff_hex: target_hex,
        hashing_blob: new_blob,
        template_blob: template_data.blocktemplate_blob.to_owned(),
        extra_nonce: extra_nonce.to_owned(),
        reserved_offset: template_data.reserved_offset,
        network_difficulty: template_data.difficulty,
        submissions: Default::default(),
      }),
      None => None
    }
  }

  pub fn refresh(&self) {
    let template = self.app.daemon.get_block_template();
    match template {
      Ok(template) => {
        if let Some(result) = template.get("result") {
          let parsed_template: StdResult<BlockTemplate, serde_json::Error> =
            serde_json::from_value(result.clone());
          if let Ok(new_template) = parsed_template {
            let mut current_template = self.template.write().unwrap();
            if new_template.prev_hash != current_template.prev_hash {
              info!("New block template of height {}.", new_template.height);
              *current_template = new_template;
            }
          }
        }
      },
      Err(message) => warn!("Failed to get new block template: {}", message)
    }
  }
}

#[derive(Deserialize, Default)]
pub struct BlockTemplate {
  // TODO eventually most of this stuff can be private
  pub blockhashing_blob: String,
  pub blocktemplate_blob: String,
  pub difficulty: u64,
  pub height: u64,
  pub prev_hash: String,
  pub reserved_offset: u32,
  pub status: String,
}

impl BlockTemplate {
  pub fn hashing_blob_with_nonce(&self, nonce: &str) -> Option<String> {
    // TODO do away with the [..] usage, turns out there are non-panic alternatives
    // TODO document this slicing stuff
    let miner_tx = format!(
      "{}{}",
      &self.blocktemplate_blob[86..((self.reserved_offset * 2 - 2) as usize)],
      nonce
    );
    let miner_tx_hash = keccak(&byte_string::string_to_u8_array(&miner_tx))[..32].to_vec();
    let hex_digits_left = (self.blocktemplate_blob.len() - miner_tx.len()) - 86;
    if (hex_digits_left - 2) % 64 != 0 {
      return None;
    }
    let mut tx_hashes = Vec::new();
    tx_hashes.push(miner_tx_hash);
    for tx_index in 0..(hex_digits_left / 64) {
      // TODO make these numbers less magic, maybe just increment an index for readability
      // TODO the "2" here assumes 1 byte for transaction count, that needs to be a varint as well
      let start = self.reserved_offset as usize * 2 + 16 + 64 * tx_index;
      tx_hashes.push(byte_string::string_to_u8_array(&self.blocktemplate_blob[start..(start + 64)]));
    }
    let num_hashes: Vec<String> = to_varint(tx_hashes.len()).iter()
      .map(|b| format!("{:02x}", b))
      .collect();
    let root_hash: Vec<String> = tree_hash(tx_hashes).iter()
      .map(|b| format!("{:02x}", b))
      .collect();
    return Some(
      format!("{}{}{}", &self.blockhashing_blob[..86], &root_hash.join(""), &num_hashes.join(""))
    );
  }
}

/// From CNS-3 section 3
/// TODO document this, and really everything else, a bit better
fn from_varint(source: &[u8]) -> (usize, usize) {
  if source[0] < 128 {
    return (source[0] as usize, 1);
  }
  let mut i = 0;
  let mut sum: usize = 0;
  while source[i] > 128 {
    let current_b128_digit = (source[i] - 128) as usize;
    // Shifting by i * 7 is multiplying by 128^i, since 128 is our base.
    sum += current_b128_digit << (i * 7);
    i += 1;
  }
  sum += (source[i] as usize) << (i * 7);
  return (sum, i + 1);
}

fn to_varint(number: usize) -> Vec<u8> {
  let mut remaining = number;
  let mut bytes = Vec::new();
  while remaining > 0 {
    bytes.push(((remaining % 128) + 128) as u8);
    remaining = remaining >> 7;
  }
  let marker_index = bytes.len() - 1;
  // The first value less than 128 marks the end of a varint byte sequence
  bytes[marker_index] -= 128;
  bytes
}

#[test]
fn test_varint() {
  assert_eq!(from_varint(&[42]), (42, 1));
  assert_eq!(from_varint(&[128 + 1, 42]), (42 * 128 + 1, 2));
  assert_eq!(from_varint(&[128 + 60, 128 + 61, 63]), (63 * 128 * 128 + 61 * 128 + 60, 3));

  assert_eq!(&to_varint(42)[..], &[42]);
  assert_eq!(&to_varint(42 * 128 + 1)[..], &[128 + 1, 42]);
  assert_eq!(&to_varint(63 * 128 * 128 + 61 * 128 + 60)[..], &[128 + 60, 128 + 61, 63]);
}

#[test]
fn test_parse_block_template() {
  let test_block = BlockTemplate {
    blockhashing_blob: "010094fed5d205e42c97122a7b61341c46881837099891d2b2587a0bde019cbae1688e41bc4\
    d70000000005c8e57bea6b5667f77529149756c249904fb346916f7580c18ea64ec793334e903".to_owned(),
    blocktemplate_blob: "010094fed5d205e42c97122a7b61341c46881837099891d2b2587a0bde019cbae1688e41bc\
    4d700000000001e1cf3701ffa5cf3705fbf3b1e40b02d2961caddbcd6294b41030ecf24fadc4229fc45c75df5def56d\
    c1841236db36380f8cce2840202bdba3913153bbbbd8c40a8b9409fe8944bb9964edd905506b558f8eadf027b858080\
    dd9da41702625f0a1c55924dedd94ae36929cfb99664176ff1d6417abfdc5bfb40daf20b9380a094a58d1d027151b66\
    783aa0ed7d3531dcc35b958945491922222327f9bd57693a18b252a6a80c0caf384a302022c8848debdf1f00e5f6a47\
    f0886e5caf027c8fd7e159277f1aa6c5a3796e49ca2b01bdcff031f0dd952991227c05512204eb76400cd8a06c30458\
    31783cd6fbdb9f50208000000000000000002cde625408d94764cf5244bff45ddb0f8d6d42d02b8c6afb99ae9dff33a\
    7bfcacae531ddf666352c45b25569c8d894ed8a327d9fb3c361ed0e7e0433190fe9fec".to_owned(),
    difficulty: 0,
    height: 0,
    prev_hash: "".to_owned(),
    reserved_offset: 285,
    status: "OK".to_owned(),
  };
  assert_eq!(test_block.blockhashing_blob,
             test_block.hashing_blob_with_nonce("0000000000000000").unwrap());

  // Kind of weird, but turns out it is possible to have blocks with just miner transactions.
  let test_empty_block = BlockTemplate {
    blockhashing_blob: "0100a5b6e1d205ae9d4d429436d01430aaed0fd1a3823c46a14b5c993e2085948e8bb148e862\
    b8000000007f8e1bb9aaccac84169ccf9a9a33ac704960e252e05218d19d93a147a396922901".to_owned(),
    blocktemplate_blob: "0100a5b6e1d205ae9d4d429436d01430aaed0fd1a3823c46a14b5c993e2085948e8bb148e8\
    62b80000000001bfd53701ff83d53705e7aee92d0236238d7c671cd670c1e5d145aa38407aa7c4caf78c9c3a5086126\
    c3d1e6d8bd48090dfc04a0288d398bf66e39e28888192a76534060cf698d293d3ed36ba25b23952ee8681a58080dd9d\
    a41702907aeacf368448e675dff25d15f74a2e55ca0155d09a6ee3ff22e9e8231e03e580a094a58d1d028cd86671141\
    36db4b05fffa7359039243594749b3241cce28a782d2ace58cb1180c0caf384a302020a1e50d39fa6615e3b3a6ca883\
    bd37a22f3870907bbc1dbbe70c1a6d6b4c1e342b01926d835f688b901dea5d5e2c0df2251a216d769b6cbabaa6fa81f\
    3797aba88cc0208000000000000000000".to_owned(),
    difficulty: 0,
    height: 0,
    prev_hash: "".to_owned(),
    reserved_offset: 283,
    status: "OK".to_owned(),
  };
  assert_eq!(test_empty_block.blockhashing_blob,
             test_empty_block.hashing_blob_with_nonce("0000000000000000").unwrap());
}

// block ends with miner_tx which is a transaction, and tx_hashes which is a list of 32-byte hashes

#[test]
fn test_tree_hash() {
  // Test case pulled from the monero project's tests directory
  let concat_hash_tests = vec![
    byte_string::string_to_u8_array("21f750d5d938dd4ed1fa4daa4d260beb5b73509de9a9b145624d3f1afb671461"),
    byte_string::string_to_u8_array("b07d768cf1f5f8266b89ecdc150a2ad55ccd76d4c12d3a380b21862809a85af6"),
    byte_string::string_to_u8_array("23269a23ee1b4694b26aa317b5cd4f259925f6b3288a8f60fb871b1ad3ac00cb"),
    byte_string::string_to_u8_array("1e6c55eddfc438e1f3e7b638ea6026cc01495010bafdfd789c47dff282c1af4c"),
    byte_string::string_to_u8_array("6a8f83e5f2fca6940a756ef4faa15c7137082a7c31dffe0b2f5112d126ad4af1"),
    byte_string::string_to_u8_array("d536c0e626cc9d2fe1b72256f5285728558f22a3dbb36e0918bcfc01d4ae7284"),
    byte_string::string_to_u8_array("d0bfb8e90647cdb01c292a53a31ff3fe6f350882f1dae2b09374db45f4d54c67"),
    byte_string::string_to_u8_array("d3b4e0829c4f9f63ad235d8ef838d8fb39546d90d99bbd831aff55dbbb642e2b"),
    byte_string::string_to_u8_array("f529ceccd0479b9f194475c2a15143f0edac762e9bbce810436e765550c69e23"),
    byte_string::string_to_u8_array("4c22276c41d7d7e28c10afc5e144a9ce32aa9c0f28bb4fcf171af7d7404fa5e2"),
    byte_string::string_to_u8_array("8b79dc97bd4147f4df6d38b935bd83fb634414bae9d64a32ab45384fba5b8da5"),
    byte_string::string_to_u8_array("c147d51cd2a8f7f2a9c07b1bddc5b28b74bf0c0f0632ac2fc43d0d306dd1ac14"),
    byte_string::string_to_u8_array("81cabe60a358d6043d4733202d489664a929d6bf76a39828954846beb47a3baa"),
    byte_string::string_to_u8_array("cb35d2065cbe3ad34cf78bf895f6323a6d76fc1256306f58e4baecabd7a77938"),
    byte_string::string_to_u8_array("8c6bf2734897c193d39c343fce49a456f0ef84cf963593c5401a14621cc6ec1b"),
    byte_string::string_to_u8_array("ef01b53735ccb02bc96c5fd454105053e3b016174437ed83b25d2a79a88268f2"),
  ];
  let test_tree_hash: Vec<String> = tree_hash(concat_hash_tests).iter()
    .map(|b| format!("{:02x}", b))
    .collect();
  assert_eq!("2d0ad2566627b50cd45125e89e963433b212b368cd2d91662c44813ba9ec90c2",
             test_tree_hash.join(""));
}


fn tree_hash_cnt(count: usize) -> usize {
  let mut i = 1;
  while i * 2 < count {
    // TODO this isn't optimal, but maybe we don't care
    i *= 2;
  }
  return i;
}

fn concat_and_hash(in1: &[u8], in2: &[u8]) -> Vec<u8> {
  let mut concatted_inputs = in1.to_vec();
  concatted_inputs.extend(in2.iter());
  return keccak(&concatted_inputs[..])[..32].to_vec();
}

// https://lab.getmonero.org/pubs/MRL-0002.pdf
fn tree_hash(hashes: Vec<Vec<u8>>) -> Vec<u8> {
  let count = hashes.len();
  if count == 1 {
    return hashes[0].to_vec();
  } else if count == 2 {
    return concat_and_hash(&hashes[0], &hashes[1]);
  } else {
    let mut cnt = tree_hash_cnt(count);
    let mut ints: Vec<Vec<u8>> = Vec::new();
    let slice_point = 2 * cnt - count;
    for i in 0..slice_point {
      ints.push(hashes[i].clone())
    }
    for _ in slice_point..count {
      ints.push(vec![0]);
    }
    let mut i = slice_point;
    for j in slice_point..cnt {
      ints[j] = concat_and_hash(&hashes[i], &hashes[i + 1]);
      i += 2;
    }

    while cnt > 2 {
      cnt /= 2;
      let mut ii = 0;
      for jj in 0..cnt {
        ints[jj] = concat_and_hash(&ints[ii], &ints[ii + 1]);
        ii += 2;
      }
    }
    return concat_and_hash(&ints[0], &ints[1]).to_vec();
  }
}
